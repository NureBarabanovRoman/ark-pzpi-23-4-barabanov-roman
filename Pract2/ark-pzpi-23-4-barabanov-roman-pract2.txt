МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ





ЗВІТ
До практичної роботи №2
З дисципліни «Аналіз та рефакторинг коду»














Виконав:
ст. гр. ПЗПІ-23-4
Барабанов Р.П.

Перевірив:
Ст. викладач кафедри ПІ
Сокорчук Ігор Петрович












Харків – 2025
2 ЗАВДАННЯ
     Мета роботи: Дослідити та систематизувати основні методи рефакторингу коду мовою Go для покращення його дизайну, читабельності та якості. Завдання полягає у вивченні та практичному застосуванні трьох ключових технік рефакторингу:
1. Extract Method (Виділення методу).
2. Replace Temp with Query (Заміна тимчасової змінної на виклик методу).
3. Simplify Conditional Expression (Спрощення умовних виразів).
     Кінцевою метою є демонстрація того, як ці методи спрощують підтримку коду та тестування.











3 ОПИС ВИКОНАНОЇ РОБОТИ
     У рамках практичної роботи було проаналізовано проблематику "брудного" коду та застосовано сучасні підходи до рефакторингу на прикладі мови Go. Було розглянуто три основні методи.
3.1 Метод Extract Method (Виділення методу)
     Проблема: Часто функції стають занадто довгими та складними, виконуючи кілька дій одночасно. Наприклад, функція CalculateInvoiceTotal в одному блоці обчислювала суму, знижку та податок, що ускладнювало її розуміння.
Рішення: Застосовано метод декомпозиції. Логіку розбито на три окремі допоміжні функції: calculateTotal, calculateDiscount та calculateTax . Це дозволило основній функції лише координувати виклики.
Приклад коду (Після рефакторингу):
01 func CalculateInvoiceTotal(prices []float64, quantities []int, 
02                            discountRate float64, taxRate float64) float64 {
03     // Виклик виділених методів
04     subtotal := calculateTotal(prices, quantities)
05     discountAmount := calculateDiscount(subtotal, discountRate)
06     
07     amountAfterDiscount := subtotal - discountAmount
08     taxAmount := calculateTax(amountAfterDiscount, taxRate)
09     
10     return amountAfterDiscount + taxAmount
11 }
Переваги:
* Покращена читабельність (кожна функція має одну відповідальність).
* Можливість повторного використання коду.
* Спрощення модульного тестування .
3.2 Метод Replace Temp with Query
     Проблема: Використання локальних тимчасових змінних для збереження проміжних результатів (наприклад, змінна discount всередині умовних блоків) робить функцію довгою та заплутаною.
Рішення: Тимчасову змінну замінено на виклик окремої функції getDiscount(), яка інкапсулює логіку розрахунку. Це робить код більш декларативним.
Приклад коду (Після рефакторингу):
01 func getDiscount(basePrice float64, isPremium bool) float64 {
02     if isPremium {
03         return basePrice * 0.10
04     }
05     return basePrice * 0.05
06 }
07
08 func CalculatePrice(price float64, quantity int, isPremium bool) float64 {
09     basePrice := getBasePrice(price, quantity)
10     // Заміна змінної на виклик функції
11     return basePrice - getDiscount(basePrice, isPremium)
12 }
Переваги:
* Зменшення кількості змінних у коді.
* Чітке відокремлення логіки розрахунку.
* Легше вносити зміни в алгоритм знижок .
3.3 Метод Simplify Conditional Expression
     Проблема: Наявність глибоко вкладених умовних виразів (nested if statements). У прикладі ValidateUser перевірки ролі, імені та пароля були вкладені одна в одну, що робило потік виконання неочевидним .
Рішення: Застосовано Guard Clauses (техніка раннього виходу) та виділення умов у окремі функції-предикати (isUsernameValid, isRoleValid). Якщо умова не виконується, функція одразу повертає false.
Приклад коду (Після рефакторингу):
01 func ValidateUser(username, password, role string, isActive bool) bool {
02     // Guard Clauses (Ранній вихід)
03     if !isUsernameValid(username) { return false }
04     if !isPasswordValid(password) { return false }
05     if !isActive { return false }
06     if !isRoleValid(role) { return false }
07     
08     return true
09 }
Переваги:
* "Плоска" структура коду, яку легко читати.
* Легке додавання нових умов валідації.
* Ізольоване тестування умов.
4 ВИСНОВКИ
     У результаті виконання роботи було проаналізовано вплив рефакторингу на якість програмного забезпечення.
1. Рефакторинг — це інвестиція. Час, витрачений на покращення структури сьогодні, знижує витрати на підтримку в майбутньому.
2. Якість коду. Чистий код зменшує кількість помилок і спрощує командну розробку.
3. Практичні навички. Регулярне використання методів, таких як Replace Temp with Query та Simplify Conditional Expression, є необхідною умовою для професійного зростання Go-розробника.








5 ПЕРЕЛІК ДЖЕРЕЛ 
1. Fowler M. Refactoring: Improving the Design of Existing Code. Addison-Wesley Professional, 2018.
2. Kerievsky J. Refactoring to Patterns. Addison-Wesley, 2004.
3. Effective Go. URL: https://go.dev/doc/effective_go
4. Martin R. C. Clean Code: A Handbook of Agile Software Craftsmanship. Prentice Hall, 2008.









ДОДАТОК А

Відеозапис

Відеозапис доповіді: https://youtu.be/btzUyCf4-so

Хронологічний опис відеозапису:
00:00 – Вступ
00:20 – Перший метод рефакторингу
01:41 – Другий метод рефакторингу
02:55 – Третій метод рефакторингу
04:27 – Висновки




ДОДАТОК Б
Слайди презентації

Рисунок Б.1 – титульний слайд

Рисунок Б.2 – обрані методи рефакторингу

Рисунок Б.3 – перший метод рефакторингу

Рисунок Б.4 – код до рефакторингу першим методом
Рисунок Б.5 – пояснення рішення

Рисунок Б.6 – код після рефакторингу першим методом

Рисунок Б.7 – переваги рефакторингу першим методом

Рисунок Б.8 – другий метод рефакторингу

Рисунок Б.9 – код до рефакторнгу другим методом
Рисунок Б.10 – пояснення рішення другим методом
Рисунок Б.11 – код після рефакторингу другим методом

Рисунок Б.12 – переваги рішення другим методом

Рисунок Б.13 – третій метод рефакторингу
Рисунок Б.14 – код до рефакторингу третім методом

Рисунок Б.15 – пояснення рішення третім методом

Рисунок Б.16 – код після рефакторингу третім методом

Рисунок Б.17 – переваги використання третього методу

Рисунок Б.18 – висновки

Рисунок Б.19 - подяка



