МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ





ЗВІТ
До практичної роботи №1
З дисципліни «Аналіз та рефакторинг коду»














Виконав:
ст. гр. ПЗПІ-23-4
Барабанов Р.П.

Перевірив:
Ст. викладач кафедри ПІ
Сокорчук Ігор Петрович












Харків – 2025
2 ЗАВДАННЯ
     Мета роботи:
     Дослідити та систематизувати основні рекомендації щодо написання чистого, ефективного та підтримуваного коду мовою програмування Go (Golang). Робота спрямована на вивчення принципів ідіоматичного Go, які забезпечують простоту та читабельність коду.
     Основним завданням є аналіз стандартів форматування (gofmt), правил іменування змінних та пакетів, ефективної обробки помилок, а також використання механізмів конкурентності (горутин та каналів). Дослідження також охоплює архітектурні патерни, принципи тестування та інструментарій для забезпечення якості коду.
     Кінцевою метою є формування навичок створення програмного забезпечення, що відповідає філософії Go: "Clear is better than clever" (Явне краще за дотепне).
     
     
     
     
     
     
     
     
     
     
     
     
     
3 ХІД РОБОТИ
     У рамках практичної роботи було детально вивчено правила оформлення програмного коду мовою Go. Робота базувалася на офіційних рекомендаціях спільноти Go та аналізі наданих навчальних матеріалів. Було розглянуто ключові аспекти: від стилю коду до розгортання додатків.
3.1 Філософія та форматування коду
     Основою розробки на Go є принцип простоти та лаконічності. Код має бути зрозумілим для колег, а не лише для комп'ютера.
     Для забезпечення єдиного стилю використовується інструмент gofmt, який автоматично форматує код, усуваючи суперечки щодо відступів та розміщення дужок. Це гарантує, що весь Go-код виглядає однаково, незалежно від автора.
Приклад правильного форматування та структури:

01 package main
02
03 import "fmt"
04
05 // CalculateSum повертає суму двох чисел.
06 // Функція експортується, тому має коментар.
07 func CalculateSum(a, b int) int {
08     return a + b
09 }
10
11 func main() {
12     sum := CalculateSum(5, 10)
13     fmt.Println("Sum:", sum)
14 }
3.2 Конвенції найменування
     Правильне іменування є критичним для читабельності. У Go використовується стиль CamelCase (MixedCaps).
Важливою особливістю мови є механізм експорту через регістр першої літери:
* Експортовані ідентифікатори (Public): Починаються з великої літери (наприклад, Client, Connect). Вони доступні з інших пакетів.
* Неекспортовані ідентифікатори (Private): Починаються з малої літери (наприклад, parser, user). Вони доступні лише всередині пакету.
* Уникнення надмірності: Якщо метод належить структурі Client, не слід називати його ClientConnect, достатньо Connect.
Приклад застосування правил іменування:

01 // Погано:
02 func ParseYAMLConfig(data []byte) (*Config, error)
03
04 // Добре (лаконічно та зрозуміло):
05 func Parse(data []byte) (*Config, error)
06
07 // Метод структури Parser:
08 func (p *Parser) Parse() (*Config, error)
3.3 Організація пакетів та структура проєкту
     Добре структуровані пакети забезпечують модульність. Кожен пакет повинен виконувати одну задачу (Single Responsibility Principle).
Рекомендується використовувати стандартну структуру проекту:
* cmd/ — для виконуваних файлів.
* pkg/ — для бібліотечного коду.
* internal/ — для приватного коду, який не повинен імпортуватися іншими проектами.
Назви пакетів мають бути короткими та в нижньому регістрі (наприклад, http, json), уникаючи загальних назв на кшталт utils.
3.4 Обробка помилок
     У Go відсутні винятки (exceptions) у традиційному розумінні. Обробка помилок базується на явному поверненні значення error.
Ідіоматичний підхід полягає у перевірці if err != nil одразу після виконання операції. Це робить потік керування передбачуваним.
Функцію panic слід використовувати лише для критичних, невідновлюваних помилок.
Приклад обробки помилок:

01 func ReadData() ([]byte, error) {
02     result, err := someOperation()
03     if err != nil {
04         // Логування та додавання контексту до помилки
05         log.Printf("Помилка операції: %v", err)
06         return nil, fmt.Errorf("operation failed: %w", err)
07     }
08     return result, nil
09 }

3.5 Конкурентність (Concurrency)
     Go надає потужні примітиви для конкурентного програмування: горутини (легковагі потоки) та канали (засоби комунікації).
Головне правило: "Не спілкуйтеся через спільну пам'ять, а використовуйте спільну пам'ять через комунікацію".
Для обмеження навантаження використовуються Worker Pools (пули робітників).
Приклад використання каналів та горутин:

01 func worker(id int, jobs <-chan int, results chan<- int) {
02     for j := range jobs {
03         results <- j * 2
04     }
05 }
06
07 func main() {
08     jobs := make(chan int, 100)
09     results := make(chan int, 100)
10
11     // Запуск 3-х робітників
12     for w := 1; w <= 3; w++ {
13         go worker(w, jobs, results)
14     }
15 }
3.6 Тестування та Інструментарій
Якісне тестування забезпечується вбудованим пакетом testing. Рекомендується використовувати табличні тести (Table-Driven Tests) для перевірки багатьох сценаріїв.
Також важливо використовувати лінтери, такі як go vet та staticcheck, для виявлення потенційних помилок ще до компіляції.




4 ВИСНОВКИ
     У результаті виконання практичної роботи було проаналізовано підходи до написання коду мовою Go.
1. Якість та Читабельність: Використання gofmt та дотримання naming conventions робить код однорідним та легким для підтримки.
2. Надійність: Явна обробка помилок (if err != nil) змушує розробника обробляти всі можливі сценарії збоїв, що підвищує стабільність системи.
3. Продуктивність: Розумне використання горутин та каналів дозволяє створювати високонавантажені системи, а уникнення передчасної оптимізації зберігає код чистим.
4. Інфраструктура: Стандартизована структура проекту (cmd, internal) та використання Docker (scratch/alpine) спрощують розгортання та CI/CD.
Застосування цих практик дозволяє створювати ідіоматичний Go-код, який є простим, ефективним та безпечним.


















5 ПЕРЕЛІК ДЖЕРЕЛ
1. Effective Go. URL: https://go.dev/doc/effective_go
2. Go Code Review Comments. URL: https://github.com/golang/go/wiki/CodeReviewComments
3. Standard Go Project Layout. URL: https://github.com/golang-standards/project-layout


























ДОДАТОК А
Відеозапис
Відеозапис доповіді: https://youtu.be/I_uJlHnghDQ
Хронологічний опис відеозапису:
00:00 – Вступ. 
00:35 – Принципи написання ідіоматичного Go-коду.
01:20 – Стандарти іменування.
03:42 – Інтерфейси та композиція.
05:25 – Тестування.
06:14 – Оптимізація продуктивності
08:18 – Безпека: Кращі практики
11:20 - Висновки















ДОДАТОК Б
     Слайди презентації


Рисунок Б.1 – титульна сторінка

Рисунок Б.2 – Вступ 

Рисунок Б.3 – принципи написання ідіоматичного Go-коду

Рисунок Б.4 – стандарти іменування в Go

Рисунок Б.5 – структура та організація пакетів Go

Рисунок Б.6 – ефективна обробка помилок в Go

Рисунок Б.7 – інтерфейси та композиція в Go

Рисунок Б.8 – шаблони конкурентності в Go

Рисунок Б.9 – тестування в Go

Рисунок Б.10 – Оптимізація продуктивності в Go

Рисунок Б.11 – інструментарій та робочий процес Go

Рисунок Б.12 – Безпека в Go

Рисунок Б.13 – структура проекту та архітектурні паттерни

Рисунок Б.14 – розгортання та продакшн

Рисунок Б.15 – Висновок

Рисунок Б.16 - подяка



